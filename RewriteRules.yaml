# Rewrite rules for the `bishop` project.

# First, we specify how to handle Prelude.
prelude:
  implicit: true
  hiding:           # if implicit is true
    - seq
    - <
    - ">"           # this prints () for some reason without the quotation marks

  #using:           # if implicit is false
  #  - _+_
  #  - Num

# The preferred naming convention. Used when rewriting illegal characters in identifiers.
name-style: camel
# Whether we should rewrite kebab-case identifiers to the preferred convention.
rewrite-kebab: true

# Rules for replacing non-allowed characters in identifiers.
# Not yet implemented.
chars:
  - from: <
    to: lt
  - from: >
    to: gt
  - from: +
    to: plus
  - from: -
    to: minus
  - from: *
    to: multi
  # etc.

# Then rules for replacing an entire identifier with another one from a given module.
rules:

  # The rational type.
  - from: Data.Rational.Unnormalised.Base.ℚᵘ
    to: Rational
    importing: Data.Ratio

  # Arithmetic operators.
  # Note: Prelude has to be specified too!
  - from: Agda.Builtin.Nat._+_
    to: _+_
    importing: Prelude
  - from: Agda.Builtin.Nat._*_
    to: _*_
    importing: Prelude
  - from: Agda.Builtin.Nat.-_
    to: negate
    importing: Prelude
  - from: Agda.Builtin.Nat._-_
    to: _-_
    importing: Prelude
  - from: Data.Nat.Base._⊔_
    to: max
    importing: Prelude

  - from: Agda.Builtin.Integer._+_
    to: _+_
    importing: Prelude
  - from: Data.Integer.Base._*_
    to: _*_
    importing: Prelude
  - from: Agda.Builtin.Integer.-_
    to: negate
    importing: Prelude
  - from: Agda.Builtin.Integer._-_
    to: _-_
    importing: Prelude

  - from: Data.Rational.Unnormalised.Base._+_
    to: _+_
    importing: Prelude
  - from: Data.Rational.Unnormalised.Base._*_
    to: _*_
    importing: Prelude
  - from: Data.Rational.Unnormalised.Base.-_
    to: negate
    importing: Prelude
  - from: Data.Rational.Unnormalised.Base._-_
    to: _-_
    importing: Prelude
  - from: Data.Rational.Unnormalised.Base._/_
    to: _//_
    importing: Base
  - from: Data.Rational.Unnormalised.Base._⊔_
    to: max
    importing: Prelude
  - from: Data.Rational.Unnormalised.Base._⊓_
    to: min
    importing: Prelude
  - from: Data.Rational.Unnormalised.Base.∣_∣
    to: abs
    importing: Prelude
  - from: Data.Integer.Base.∣_∣
    to: intAbs
    importing: Base

  # Standard library functions related to naturals and integers.
  - from: Agda.Builtin.Nat.Nat.suc
    to: suc
    importing: Base
  - from: Data.Nat.Base.pred
    to: predNat
    importing: Base
  - from: Agda.Builtin.Int.Int.pos
    to: toInteger
    importing: Prelude
  - from: Data.Integer.DivMod._divℕ_
    to: divNat
    importing: Base
  - from: Data.Nat.DivMod._/_
    to: div
    importing: Prelude

  # Standard library functions related to rationals.
  - from: Data.Rational.Unnormalised.Base.ℚᵘ.numerator
    to: numerator
    importing: Data.Ratio
  - from: Data.Rational.Unnormalised.Base.ℚᵘ.denominator
    to: denominatorNat
    importing: Base       #the Base version returns a Natural
  - from: Data.Rational.Unnormalised.Base.ℚᵘ.denominator-1
    to: denominatorMinus1                                # this is not too pretty now, but that's a temporary solution until denominatorℕ gets fixed
    importing: Base
  - from: Inverse.erased-1/_                             # this is ours, but still, logically it belongs here
    to: recip
    importing: Prelude

  # For '-ed functions in our own modules.
  - from: ExtraProperties.fastArchimedeanℚ
    to: archimedeanℚ'
    importing: ExtraProperties
  - from: ExtraProperties.fastArchimedeanℚ₂
    to: archimedeanℚ₂'
    importing: ExtraProperties
  - from: Real.sum
    to: sum'
    importing: Real
  - from: Real.max
    to: max'
    importing: Real
  - from: RealProperties.fastEqualityLemmaIf
    to: equalityLemmaIf'
    importing: RealProperties
  - from: RealProperties.fastLemma282If
    to: RealProperties.lemma282If'
    importing: RealProperties
  - from: RealProperties.zeroLtpThenZeroLtToRealp
    to: zeroLtpThenZeroLtToRealp'
    importing: RealProperties

  # This way, it doesn't recognise these; unfortunately, we have to include them in rules.
  # For tuples.
  - from: Haskell.Prim.Tuple.fst
    to: fst
    importing: Prelude
  - from: Haskell.Prim.Tuple.snd
    to: snd
    importing: Prelude
  # For Either similarly.
  - from: Haskell.Prim.Either.Either
    to: Either
    importing: Prelude
  - from: Haskell.Prim.Either.Either.Left
    to: Left
    importing: Prelude
  - from: Haskell.Prim.Either.Either.Right
    to: Right
    importing: Prelude